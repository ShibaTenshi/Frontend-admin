import{h as k}from"./index.344f9f74.js";import{a0 as E,r as b,B as R,H as B,a1 as F,y as P,z,a2 as A,i as h,a3 as H,a4 as M,v as T,A as U,a5 as $}from"./entry.abf80c1c.js";function q(...i){var p;const f=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(f);let[t,r,a={}]=i;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof r!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const e=A(),u=()=>null,_=()=>e.isHydrating?e.payload.data[t]:e.static.data[t];a.server=a.server??!0,a.default=a.default??u,a.getCachedData=a.getCachedData??_,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??E.deep;const y=()=>![null,void 0].includes(a.getCachedData(t));if(!e._asyncData[t]||!a.immediate){(p=e.payload._errors)[t]??(p[t]=null);const o=a.deep?b:R;e._asyncData[t]={data:o(a.getCachedData(t)??a.default()),pending:b(!y()),error:B(e.payload._errors,t),status:b("idle")}}const s={...e._asyncData[t]};s.refresh=s.execute=(o={})=>{if(e._asyncDataPromises[t]){if(o.dedupe===!1)return e._asyncDataPromises[t];e._asyncDataPromises[t].cancelled=!0}if((o._initial||e.isHydrating&&o._initial!==!1)&&y())return Promise.resolve(a.getCachedData(t));s.pending.value=!0,s.status.value="pending";const l=new Promise((n,c)=>{try{n(r(e))}catch(g){c(g)}}).then(n=>{if(l.cancelled)return e._asyncDataPromises[t];let c=n;a.transform&&(c=a.transform(n)),a.pick&&(c=L(c,a.pick)),s.data.value=c,s.error.value=null,s.status.value="success"}).catch(n=>{if(l.cancelled)return e._asyncDataPromises[t];s.error.value=n,s.data.value=h(a.default()),s.status.value="error"}).finally(()=>{l.cancelled||(s.pending.value=!1,e.payload.data[t]=s.data.value,s.error.value&&(e.payload._errors[t]=H(s.error.value)),delete e._asyncDataPromises[t])});return e._asyncDataPromises[t]=l,e._asyncDataPromises[t]};const v=()=>s.refresh({_initial:!0}),w=a.server!==!1&&e.payload.serverRendered;{const o=M();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const n=o._nuxtOnBeforeMountCbs;o&&(F(()=>{n.forEach(c=>{c()}),n.splice(0,n.length)}),P(()=>n.splice(0,n.length)))}s.error.value||w&&e.isHydrating&&y()?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):o&&(e.payload.serverRendered&&e.isHydrating||a.lazy)&&a.immediate?o._nuxtOnBeforeMountCbs.push(v):a.immediate&&v(),a.watch&&z(a.watch,()=>s.refresh());const l=e.hook("app:data:refresh",async n=>{(!n||n.includes(t))&&await s.refresh()});o&&P(l)}const D=Promise.resolve(e._asyncDataPromises[t]).then(()=>s);return Object.assign(D,s),D}function L(i,f){const t={};for(const r of f)t[r]=i[r];return t}function G(i,f,t){var C;const[r={},a]=typeof f=="string"?[{},f]:[f,t],e=T(()=>{let m=i;return typeof m=="function"&&(m=m()),h(m)}),u=r.key||k([a,((C=h(r.method))==null?void 0:C.toUpperCase())||"GET",h(r.baseURL),typeof e.value=="string"?e.value:"",h(r.params||r.query),h(r.headers)]);if(!u||typeof u!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+u);if(!i)throw new Error("[nuxt] [useFetch] request is missing.");const _=u===a?"$f"+u:u;if(!r.baseURL&&typeof e.value=="string"&&e.value.startsWith("//"))throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:y,lazy:s,default:v,transform:w,pick:D,watch:p,immediate:o,getCachedData:l,deep:n,...c}=r,g=U({...$,...c,cache:typeof r.cache=="boolean"?void 0:r.cache}),O={server:y,lazy:s,default:v,transform:w,pick:D,immediate:o,getCachedData:l,deep:n,watch:p===!1?[]:[g,e,...p||[]]};let d;return q(_,()=>{var x;return(x=d==null?void 0:d.abort)==null||x.call(d),d=typeof AbortController<"u"?new AbortController:{},typeof e.value=="string"&&e.value.startsWith("/"),(r.$fetch||globalThis.$fetch)(e.value,{signal:d.signal,...g})},O)}export{G as u};
